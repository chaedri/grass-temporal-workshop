<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Spatio-temporal data handling and visualization in GRASS GIS</title>
  <meta name="description" content="">
  <meta name="author" content="">
  <link rel="shortcut icon" href="grass.png">

  <script src="jquery.js"></script>

<!--
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/default.min.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
-->

<link rel="stylesheet" href="highlightjs/styles/default.css">
<script src="highlightjs/highlight.pack.js"></script>


<style>
.hljs{
    display: none;
    /*padding: 0em;*/
}

</style>


  <link rel="stylesheet" href="grassdocs.css">
  <link rel="stylesheet" href="codetabs.css">

</head>

<body>

<h1>Spatio-temporal data handling and visualization in GRASS GIS</h1>
<h2 class="notoc">FOSS4G 2014 workshop</h2>
<p>
Vaclav Petras,
Anna Petrasova,
Helena Mitasova,
Markus Neteler
</p>

<p>
  <a href="https://2014.foss4g.org" title="FOSS4G 2014"><img src="foss4g-2014.png" alt="FOSS4G 2014 logo"></a>
  <a href="http://grass.osgeo.org" title="GRASS GIS"><img src="grass-large.png" alt="GRASS GIS logo"></a>
</p>

<p>
Outline:
<ul>
<li> Quick <a href="./GRASS_intro.pdf">introduction to GRASS GIS</a> and <a href="./TGRASS_intro.pdf">GRASS Temporal Framework</a></li>
<li> <a href="#climate-data-analysis">analyze and visualize climate data</a>
<li> <a href="#nagshead-series">process coastal terrain time series and visualize space-time cube</a>
<li> <a href="#visualization-of-solar-radiation">compute and visualize solar radiation dynamics</a>
</ul>

<p>
Software:
<ul>
<li>GRASS GIS 7</li>
<li>matplotlib with pyplot
(included in GRASS installation for MS Windows; package python-matplotlib for Ubuntu)</li>
</ul>

<p>
Data:
<ul>
<li>location <a href="./NC_spm_temporal_workshop.zip">NC_spm_temporal workshop</a>
<ul>
<li>mapset <code>climate_2000_2012</code>: temperature and precipitation series for the whole North Carolina</li>
<li>mapset <code>NagsHead_series</code>: elevation data time series, derived from lidar data</li>
<li>mapset <code>centennial</code>: DEM of part of Centennial campus, NC State University, derived from lidar data</li>
</ul>
<li>alternative color tables:
    <a href="http://courses.ncsu.edu/mea592/common/Assign_GISmdmodel/temperature_color.txt">temperature</a>,
    <a href="http://courses.ncsu.edu/mea592/common/Assign_GISmdmodel/precip_color.txt">precipitation</a>
</li>
</ul>

<p>
Terminology:
<ul>
<li>map in GRASS describes a spatial phenomenon, map is stored in GRASS database,
  it can be raster, vector, or 3D raster (other GIS systems often call this a layer)</li>
<!--
<li>raster map usually describes a continuous spatial phenomena, examples include precipitation and aerial image</li>
<li>vector map usually describes a discrete spatial phenomena, for example meteorological stations</li>
-->
<li>3D raster is a three dimensional raster, alternative names include voxel, voxel model and volume</li>
<li>spatio-temporal dataset in GRASS is a set of GRASS maps registered in GRASS temporal database</li>
<li>
  GRASS module is one function, procedure or algorithm,
  it can be also referred as command especially when also all parameters are given
  (other systems use also terms tool and program),
  module can be invoked from GUI, Python or system command line
</li>
<li>GUI is a graphical user interface, i.e. the windows which user usually sees after starting GRASS GIS
  (GUI in GRASS GIS is often referred as wxGUI because of the underlying technology)</li>
</ul>

<p>
Notes:
<ul>
<li>To run commands in GUI, fill the module
  parameters into a proper form or just type the relevant command
  into the command console in GUI and press enter.</li>
</ul>


<h2 id="climate-data-analysis">Climate data analysis</h2>

<h3>Basic commands and visualizations</h3>
<p>
Start GRASS with location NC_spm_temporal_workshop and mapset climate_2000_2012.
First we list available raster maps and display the first temperature
and precipitation maps from the series to make ourselves familiar with the data.

<!-- TODO: things with stdout cannot work with run_command, needs read_command -->
<pre>
<code class="neutral">
g.list type=rast
g.mlist type=rast pattern="*tempmean"
g.mlist type=rast pattern="*precip"
</code>
</pre>

<pre>
<code class="gui">
In Layer Manager menu: File -> Map display -> Add raster (also available on toolbar)
Select raster map '2000_01_tempmean'
In the same way display raster map '2000_01_precip'
</code>
<code class="bash">
# start monitor
d.mon wx0
# display raster maps
d.rast 2000_01_tempmean
d.rast 2000_01_precip
</code>
</pre>

To better handle the long time series of maps, we create temporal datasets
which serve as containers for the time series and we will further manipulate
them instead of the individual maps. First, we create empty datasets of type
strds (space-time raster dataset). Note, that we use absolute time.
<!-- TODO: explain what is temporal dataset "think about container", the type is strds STRDS-->

<pre>
<code>
t.create output=tempmean type=strds temporaltype=absolute title="Average temperature" description="Monthly temperature average in NC [deg C]"
t.create output=precip_sum type=strds temporaltype=absolute title="Preciptation" description="Monthly precipitation sums in NC [mm]"
</code>
</pre>

<p>
Now we register raster maps into yet empty space-time raster datasets
with start date 2000-01-01 and interval time with increment 1 month. 
We use g.mlist again (or g.list in future GRASS versions) to list them:

<pre>
<code class="gui">
List temperature raster maps with g.mlist:
    g.mlist type=rast pattern="*tempmean" --quiet

Then launch t.register and copy and paste output of g.mlist to file parameter of t.register
(input field under 'or enter values interactively'). In t.register dialog, set additional values:

tab Input: input=tempmean, type=rast
tab Time Date: start=2000-01-01, increment="1 months", -i

Do the same for precipitation:
    g.mlist type=rast pattern="*precip" --quiet
And than copy and paste output to the appropriate field in t.register and use parameters:

tab Input: input=precip_sum, type=rast
tab Time Date: start=2000-01-01, increment="1 months", -i
</code>
<code class="bash">
# first list maps to check the pattern and output
g.mlist type=rast pattern="*tempmean" separator=comma --quiet
g.mlist type=rast pattern="*precip" separator=comma --quiet

# then use backticks to pass the maps directly to t.register
t.register -i input=tempmean type=rast start=2000-01-01 increment="1 months" \
    maps=`g.mlist type=rast pattern="*tempmean" separator=comma --quiet`
t.register -i input=precip_sum type=rast start=2000-01-01 increment="1 months" \
    maps=`g.mlist type=rast pattern="*precip" separator=comma --quiet`
</code>
</pre>

<p>
Make sure the datasets are created and populated correctly:
<pre>
<code class="neutral">
t.list type=strds
t.rast.list input=tempmean sep=tab
</code>
</pre>

<p>
Since the result of t.rast.list is easily parseable but not so easy to read by humans,
we will visualize the temporal extents of the dataset:

<pre>
<code class="gui">
Menu: Temporal -> GUI tools -> Plot temporal extents
Select dataset tempmean
</code>
<code class="bash">
g.gui.timeline tempmean
</code>
</pre>
<img src="./pictures/timeline_tempmean.png" alt="plot of temporal extents of tempmean strds"
title="Plot of temporal extents of space-time raster dataset tempmean"/>


<!--
<p>
Another example of listing maps of our registered dataset,
this time we list maps with temporal resolution (granularity) 2 years:

<pre>
<code>
t.rast.list input=tempmean method=gran granule="2 years" sep=tab
</code>
</pre>
<pre>
<samp>
id	name	mapset	start_time	end_time	interval_length	distance_from_begin
2000_01_tempmean@climate_2000_2012	2000_01_tempmean	climate_2000_2012	2000-01-01 00:00:00	2002-01-01 00:00:00	731.0	0.0
2002_01_tempmean@climate_2000_2012	2002_01_tempmean	climate_2000_2012	2002-01-01 00:00:00	2004-01-01 00:00:00	730.0	731.0
2004_01_tempmean@climate_2000_2012	2004_01_tempmean	climate_2000_2012	2004-01-01 00:00:00	2006-01-01 00:00:00	731.0	1461.0
2006_01_tempmean@climate_2000_2012	2006_01_tempmean	climate_2000_2012	2006-01-01 00:00:00	2008-01-01 00:00:00	730.0	2192.0
2008_01_tempmean@climate_2000_2012	2008_01_tempmean	climate_2000_2012	2008-01-01 00:00:00	2010-01-01 00:00:00	731.0	2922.0
2010_01_tempmean@climate_2000_2012	2010_01_tempmean	climate_2000_2012	2010-01-01 00:00:00	2012-01-01 00:00:00	730.0	3653.0
2012_01_tempmean@climate_2000_2012	2012_01_tempmean	climate_2000_2012	2012-01-01 00:00:00	2014-01-01 00:00:00	731.0	4383.0
</samp>
</pre>
-->

<!--
comment this out if necessary

<p>
Query space-time raster dataset in a point and display the values in a plot
(available only in the newest GRASS GIS 7 version).
<pre>
<code>
g.gui.tplot inputs=precip_sum coordinates=366165,218084
</code>
</pre>
<img src="./pictures/tplot_precip_sum.png" alt="plot of values from certain coordinate"/>
-->
<p>
Now we are going to animate part of the dataset. We will first extract year 2010 from both space-time raster datasets.
In this case, no new maps are created, the newly created dataset just points to the old maps.
<pre>
<code>
t.rast.extract input=tempmean output=tempmean_2010 where="start_time &gt;= '2010-01-01' and start_time &lt; '2011-01-01'"
t.rast.extract input=precip_sum output=precip_sum_2010 where="start_time &gt;= '2010-01-01' and start_time &lt; '2011-01-01'"
</code>
</pre>

Look at the temporal extents:
<pre>
<code class="gui">
Menu: Temporal -> GUI tools -> Plot temporal extents
Select datasets tempmean, precip_sum, tempmean_2010, precip_sum_2010
</code>
<code class="bash">
g.gui.timeline inputs=tempmean,precip_sum,tempmean_2010,precip_sum_2010
</code>
</pre>
<img src="./pictures/timeline_extracted.png" alt="extracted datasets"/>

<p>
Create an animation of temperatures in 2010 (as in the picture) by following these steps:
<p>
<img src="./pictures/anim1_result1.png" style="width: 400px;" alt="Result from Animation Tool (one animation)"/>
<ul>
<li>Run Animation tool (in menu find Temporal > GUI tools > Animation tool) 
and add animation using these <a href="./pictures/anim1.png">screenshot instructions</a>
for <code>tempmean_2010</code>.</li>
<li> When the animation is done, we can change the time format to better
suit our case: go to Settings dialog (accessible from toolbar) and choose a suitable format from the drop-down list.</li>
<li>To display legend, we first have to get minimum and maximum values of the entire dataset.
We get these values by running t.info. Then, in the 'Edit animation' dialog, check legend,
set option 'rast' to one of the maps of the dataset,
and set 'range' option to the min and max values got from t.info.
<pre>
<code class="neutral">
t.info tempmean_2010
</code>
<code class="bash">
t.info tempmean_2010
</code>
<code class="python">
grass.read_command('t.info', input='tempmean_2010')
</code>
</pre>
<pre>
<samp>
+-------------------- Space Time Raster Dataset -----------------------------+
|                                                                            |
+-------------------- Basic information -------------------------------------+
| ...
+-------------------- Absolute time -----------------------------------------+
| ..
+-------------------- Spatial extent ----------------------------------------+
| ...
+-------------------- Metadata information --------------------------------+
| Raster register table:...... raster_map_register_89c7821c3f174f3e965f481dfbd0c8d7
| North-South resolution min:. 500.0
| North-South resolution max:. 500.0
| East-west resolution min:... 500.0
| East-west resolution max:... 500.0
| Minimum value min:.......... -6.464337
| Minimum value max:.......... 18.54137
| Maximum value min:.......... 4.247691
| Maximum value max:.......... 28.805381
| Aggregation type:........... None
| Number of registered maps:.. 12
| ...
</samp>
</pre>
</li>

<li>And now add a second animation with <code>precip_sum_2010</code> so that we can see the temperature
and precipitation synchronized.</li>

<li>Change color table if desired (to built-in color table precipitaton_monthly or create your own color table).
To see the change in the animation tool, click on Render map which reloads all maps.
<pre>
<code>
t.rast.colors input=precip_2010 color=precipitation_monthly
</code>
</pre>
</li>
</ul>
<p>
<img src="./pictures/anim1_result.png" style="width: 600px;" alt="Result from Animation Tool (two animations)"/>


<p>
Now we go back to the extracted dataset and look at some other options
to explore data using again t.rast.list:
<pre>
<code class="neutral">
# start with simple listing
t.rast.list input=tempmean_2010
# we can choose different columns and order
t.rast.list input=tempmean_2010 columns=name,start_time,end_time,min,max sep="  "
t.rast.list input=precip_sum_2010 columns=start_time,min order=min sep="  "
</code>
</pre>

<p>
Here we compute univariate statistics using t.rast.univar with temporal 'where' option to limit output.
The default separator (pipe) can be changed with separator option.
<pre>
<code class="neutral">
t.rast.univar input=tempmean_2010 where="start_time &gt; '2010-10-01'"
</code>
</pre>
<pre>
<samp>
id|start|end|mean|min|max|mean_of_abs|stddev|variance|coeff_var|sum|null_cells|cells
2010_10_tempmean@climate_2000_2012|2010-10-01 00:00:00|2010-11-01 00:00:00|16.2275459748922|9.80648888481988|19.2237726847331|16.2275459748922|1.83784116074554|3.37766013213051|11.3254410962021|8233321.31864314|503233|1010600
2010_11_tempmean@climate_2000_2012|2010-11-01 00:00:00|2010-12-01 00:00:00|10.0550104277932|3.83957968817817|13.2355732387967|10.0550104277932|1.49157983140112|2.2248103934426|14.8341947739629|5101580.47571814|503233|1010600
2010_12_tempmean@climate_2000_2012|2010-12-01 00:00:00|2011-01-01 00:00:00|0.929180131463252|-6.46433724297418|4.24769083658854|1.58153627012032|1.56125262006063|2.43750974364618|168.024752918684|471435.335760116|503233|1010600
</samp>
</pre>


<p>
Finally we remove these two extracted spatio-temporal datasets. Note: in this case we remove just the "container",
not the actual maps, as we can see from the output of g.mlist.
<pre>
<code class="neutral">
t.remove inputs=tempmean_2010,precip_sum_2010
t.list type=strds
g.mlist type=rast pattern="2010*tempmean"
</code>
</pre>



<h3>Time series analysis</h3>

<p>
We will start by computing average temperature for each season of the year (we use term aggregation).
We specify 'where' option to start aggregating the first of March 2000 because winter season 2000 is not complete.

<pre>
<code>
t.rast.aggregate input=tempmean output=tempmean_seasonal base=tempmean_seasonal granularity="3 months" method=average where="start_time &gt;= '2000-03-01' and start_time &lt; '2012-11-01'"
</code>
</pre>

<p>
Extract summer periods and convert to degrees Fahrenheit.
SQLite function <tt>strftime('%m', start_time)</tt> returns the month of
the map start timestamp.
Note that <tt>strftime</tt> function is not a GRASS function.
It is specific to SQLite (temporal database) backend,
you need to use something different if you are using PostgreSQL backend.
Using nprocs=4 we are telling t.rast.extract to use 4 processes which will be
distributed to 4 processor cores if available.

<pre>
<code>
t.rast.extract input=tempmean_seasonal where="strftime('%m', start_time)='06'" expression="(tempmean_seasonal  * 9.0/5.0) + 32" output=tempmean_F_summer base=tempmean_F_summer nprocs=4
</code>
</pre>
<img src="./pictures/timeline_tempmean_seasonal.png" alt="temporal extents of tempmean_seasonal"/>
<p>
Show plot of min and max values of summer periods.
We will first create a file with those values.
If you want, set working directory from menu in GUI or by <tt>cd</tt> command,
otherwise you will have to use full path instead of just a file name.

<pre>
<code class="gui">
Run t.rast.list with following parameters:

tab Required: input=tempmean_F_summer
tab Formatting: separator=comma
tab Selection: columns=start_time,min,max

Copy output to a file named temperatures.txt.
Note that you will need full path to the file in the next step.
Note that some editors add txt extension even when you specify it
resulting in two txt extensions which may not be visible in some file browsers
(this is mainly problem on MS Windows).
</code>
<code class="bash">
# you must be in the same current working directory as you use in GUI
# or you must use full path
t.rast.list input=tempmean_F_summer columns=start_time,min,max separator=comma > temperatures.txt
</code>
</pre>

<p>
Now go to Python shell tab in the wxGUI and copy and paste and execute
(row by row):

<pre>
<code class="python">
# remember to use the full path to the file if necessary
import matplotlib.pyplot as plt
plt.plotfile("temperatures.txt", cols=(0,1,2), delimiter=',', subplots=False)
plt.show()
</code>
</pre>

<img src="./pictures/plot_summer_minmax.png" alt="minimum and maximum temperatures in summer"/>


<p>
Let's do the same with precipitation dataset in a different way.
Aggregate data using time intervals of tempmean_F_summer.
Convert millimeters to inches.

<pre>
<code>
t.rast.aggregate.ds input=precip_sum sample=tempmean_F_summer output=precip_summer base=precip_summer method=average
t.rast.mapcalc inputs=precip_summer expression="precip_summer / 25.4" output=precip_inch_summer base=precip_inch_summer nprocs=4
</code>
</pre>

<p>
Is precipitation and temperature correlated?
We will use r.regression.series, which is a GRASS addon. If you don't have it installed,
use g.extension to download it from GRASS Addons:

<pre>
<code class="neutral">
g.extension extension=r.regression.series
</code>
</pre>

<p>
Now we determine the correlation. Note that r.regression.series does not accept 
spatio-temporal datasets yet, just individual maps:

<pre>
<code class="gui">
Run g.mlist two times: 

    g.mlist type=rast pattern="tempmean_F_summer*" separator=comma --q
    g.mlist type=rast pattern="precip_inch_summer*" separator=comma --q

and then use the outputs as inputs to xseries and yseries parameters of
the r.regression.series module instead of the dots:

    r.regression.series xseries=... yseries=... output=corr method=corcoef
</code>
<code class="bash">
# using backticks syntax for two g.mlist runs
r.regression.series \
    xseries=`g.mlist type=rast pattern="tempmean_F_summer*" separator=comma --q` \
    yseries=`g.mlist type=rast pattern="precip_inch_summer*" separator=comma --q` \
    output=corr method=corcoef
</code>
</pre>

<p>
Set color table of <code>corr</code> raster map to differences color table.
<pre>
<code>
r.colors map=corr color=differences
</code>
</pre>

<p>
Now we can explore the map <code>corr</code> showing mostly negative
spatial correlation between temperature and precipitation.
<pre>
<code class="gui">
Add raster map layer -> select corr
Add map elements -> Show/hide legend
</code>
<code class="bash">
# display raster maps
d.rast corr
d.legend corr
</code>
</pre>
<img src="./pictures/corr.png" alt="temperature and precipitation spatially correlated"/>


<p>
Now we will plot temperatures in Raleigh and Ashville. First we create vector maps
with sampling locations.

<pre>
<code class="gui">
Use interactive input box in v.in.ascii dialog
or add the following line with coordinates to a newly created point.txt file:
638863,225446
287621,210637
and use the following parameters:

tab Required: input=point.txt output=towns 
tab Input format: separator=comma
tab Points: -t
</code>
<code class="bash">
echo "638863,225446
      287621,210637" | v.in.ascii -t input=- output=towns separator=comma
</code>
</pre>


<p>
Then, using t.vect.observe.strds, we create a space-time vector dataset
with values of summer temperature in those two locations stored in the attribute tables:

<pre>
<code>
t.vect.observe.strds input=towns strds=tempmean_F_summer output=towns_tempmean_summer vector_output=towns_summer column=tempmean
</code>
</pre>

<p>
Now we list temperature values:

<pre>
<code class="gui">
Run t.vect.db.select and get values for Raleigh. Save the result into a text file and name it raleigh.txt:
    t.vect.db.select input=towns_tempmean_summer columns=tempmean separator=comma where="cat = 1"

Then get values for Asheville and again save the result into file asheville.txt:
    t.vect.db.select input=towns_tempmean_summer columns=tempmean separator=comma where="cat = 2"
</code>
<code class="bash">
t.vect.db.select input=towns_tempmean_summer columns=tempmean separator=comma where="cat = 1" > raleigh.txt
t.vect.db.select input=towns_tempmean_summer columns=tempmean separator=comma where="cat = 2" > asheville.txt
</code>
</pre>

<p>
Plot the values using matplotlib in GUI in Python console
(note that this is just basic plotting to avoid more complicated code):
<pre>
<code class="python">
plt.plotfile("raleigh.txt", cols=(0,2), delimiter=',', subplots=False)
plt.plotfile("asheville.txt", cols=(0,2), delimiter=',', subplots=False, newfig=False)
plt.show()
</code>
</pre>
<img src="./pictures/plot_summer_towns.png" alt="plot of summer temperatures in two towns"/>

<p>
Now we will display an animation of summer temperature in North Carolina
and we will overlay the vector points representing the two towns.
Before we display the maps, we set color table of the entire time series.

<pre><code class="neutral">
t.rast.colors input=tempmean_F_summer color=byr
g.gui.animation strds=tempmean_F_summer
</code></pre>

Open the edit dialog and add vector layer, you can set its properties (change symbol).
Make sure the vector map layer is above the temperature series layer.
Also, you can add legend (similarly as in previous animations).
<p>
<img src="./pictures/anim2_result.png" alt="animation of summer temperature in North Carolina"/>

<h2 id="nagshead-series">NagsHead series</h2>

<p>
Start grass7 with location NC_spm_temporal_workshop and mapset NaghHead_series.

<p>
First, we create an empty space-time raster dataset. We will use relative time with years as units.

<pre>
<code>
t.create output=NagsHead_99_08 type=strds temporaltype=relative title="Nags Head elevation series" description="from 1999 to 2008 with gaps"
</code>
</pre>

<!--
<p>
Check whether it was successfull:
<pre>
<code>
t.list type=strds
</code>
</pre>
-->
<p>
Register maps in the dataset using the list of maps bellow.
Each map has an associated year. The default separator is a pipe.

<pre>
<code class="gui">
In t.register dialog, use an interactive input box for the file option and
copy and paste the list of the maps:
NH_1999_1m|1999
NH_2001_1m|2001
NH_2004_1m|2004
NH_2005_1m|2005
NH_2007_1m|2007
NH_2008_1m|2008

Also, use the other options bellow:

tab Input: input=NagsHead_99_08, type=rast
tab Time Date: unit=years
</code>
<code class="bash">
echo "NH_1999_1m|1999
      NH_2001_1m|2001
      NH_2004_1m|2004
      NH_2005_1m|2005
      NH_2007_1m|2007
      NH_2008_1m|2008" > NH.txt
t.register input=NagsHead_99_08 type=rast file=NH.txt unit=years
</code>
</pre>

<p>
Check dataset again, pay special attention to 'Relative time' section
and a number of registered maps under 'Metadata information'.

<pre>
<code class="neutral">
t.info input=NagsHead_99_08
t.rast.list input=NagsHead_99_08
g.gui.timeline NagsHead_99_08
</code>
</pre>
<img src="./pictures/timeline_nagshead_gaps.png" alt="temporal extents of NagsHead dataset"/>


<p>
Since there are gaps in the dataset, we need to interpolate missing data.
The interpolated maps are <em>already in the mapset</em> so we will skip this step now.
(The maps were linearly interpolated with r.series.interp. For interval data,
you could use t.rast.gapfill.)
<!--
<pre>
<code>
g.region rast=NH_1999_1m -p
r.series.interp input=NH_1999_1m,NH_2001_1m,NH_2004_1m,NH_2005_1m,NH_2007_1m,NH_2008_1m datapos=1999,2001,2004,2005,2007,2008 output=NH_2000_1m_interp,NH_2002_1m_interp,NH_2003_1m_interp,NH_2006_1m_interp sampl=2000,2002,2003,2006
</code>
</pre>
-->
<p>
Now we register interpolated maps to the existing dataset.

<pre>
<code class="gui">
Use interactive input for the file option in the dialog of t.register
module. Use parameters input=NagsHead_99_08 and unit=years.
Here is the list of maps to be registered including the time stamps:

NH_2000_1m_interp|2000
NH_2002_1m_interp|2002
NH_2003_1m_interp|2003
NH_2006_1m_interp|2006
</code>
<code class="bash">
echo "NH_2000_1m_interp|2000
      NH_2002_1m_interp|2002
      NH_2003_1m_interp|2003
      NH_2006_1m_interp|2006" > interp.txt

t.register input=NagsHead_99_08 file=interp.txt unit=years
</code>
</pre>

<p>
Check what you have now in the temporal database.
Set the same color table for all maps.

<pre>
<code class="neutral">
t.rast.list input=NagsHead_99_08
t.rast.colors input=NagsHead_99_08 raster=NH_1999_1m
g.gui.timeline NagsHead_99_08
</code>
</pre>

<p>
Display animation of space-time raster data set, first just in 2D.

<pre>
<code class="neutral">
g.gui.animation strds=NagsHead_99_08
</code>
<code class="gui">
In main menu find Temporal > GUI tools > Animation tool.
</code>
</pre>

<!--
maps = grass.read_command('t.rast.list', input='NagsHead_99_08', method='comma').strip().split(',')
for map in maps:
    name, mapset = map.split('@')
    grass.run_command('r.contour', flags='t', input=name, output=name + '_contour', step=2, cut=50)
-->
<p>
We can also display 2D and 3D animation side by side. To display animation in 3D,
we first have to prepare and store 3D view parameters. To do that, launch GUI if not already launched,
add e.g. NH_1999_1m, go to 3D view, set view as desired and fine resolution set to 1
(see <a href="http://grass.osgeo.org/grass70/manuals/wxGUI.nviz.html#3d-view-layer-manager-toolbox">GUI manual</a>),
 and save workspace file (in menu File -> Workspace -> Save).
In Animation tool, add animation, choose 3D mode, set workspace file,
and leave there <tt>elevation_map</tt>.
Note that 3D in Animation tool (as well as m.nviz.image command bellow)
is not supported on MS Windows.
<p>
<!-- got black box for 3D animation on 10.6, try it on Mac 10.8. -->
<img src="./pictures/anim4_result.png" alt="NagsHead series 2D and 3D animation" style="width: 600px;"/>

<p>
Sidenote: for scripting or working in command line, you can save your 3D settings
as m.nviz.image command using the button on GIS Layer manager (second row) called 'Generate command for m.nviz.image'.
Here is an example of a saved command:

<!-- TODO: implement saving as python -->
<pre>
<code>
m.nviz.image elevation_map=NH_1999_1m -a mode=fine resolution_fine=1 color_map=NH_1999_1m position=0.94,0.87 height=789 perspective=15 twist=0 zexag=2.000000 focus=487,469,8 light_position=0.68,-0.68,0.80 light_brightness=80 light_ambient=20 light_color=255:255:255 output=nviz_output format=ppm size=718,699
</code>
</pre>

<h3>Space-time cube representation</h3>
<p>
Space-time cube is 3-dimensional representation where z-coordinate is time.
We use 3D raster to represent space-time cube with z-coordinates as values of the 3D raster.
<p>
To create space-time cube we vertically stack the series of digital elevation models:

<pre>
<code class="neutral">
t.rast.to.rast3 input=NagsHead_99_08 output=NagsHead_99_08_vol
r3.info -g map=NagsHead_99_08_vol
g.region rast3d=NagsHead_99_08_vol -p3
</code>
</pre>

<!-- TODO: see how this is in 70 branch, display legend -->
<p>
Now, create a new 3D raster which will be used for coloring isosurfaces by years.

<pre>
<code>
t.rast.mapcalc inputs=NagsHead_99_08 expression="start_time() + 1999" output=NagsHead_years basename=NagsHead_years nprocs=4
t.rast.to.rast3 input=NagsHead_years output=NagsHead_years_vol

# set color table of the space-time cube 3D raster and the second 3D raster
r3.colors map=NagsHead_99_08_vol color=elevation
r3.colors map=NagsHead_years_vol color=bcyr
</code>
</pre>

<p>
Now we will display the space-time cube in 3D. Follow the instructions below:
<pre>
<code class="gui">
# set lower resolution to speed up 3D rendering
g.region -p3 res3=3 tbres=1

# first we add DEM from 2008 which was divided by 20 for visualization purpose in 3D view
# because we have to use big exaggeration for the 3D raster
Add raster map layer -> select NH_2008_1m_0.05
Add various raster map layers -> Add 3D raster map layer -> select NagsHead_99_08_vol
Right click on 3D raster -> Zoom to selected map
Paste d.legend command into GUI Command console:
d.legend -f rast3d=NagsHead_years_vol at=5,50,7,10 use=1999,2000,2001,2002,2003,2004,2005,2006,2007,2008
Switch to 3D view (be patient)
On View page, set z-exaggeration to 20 and view height to 100.
On Data page -> Surface, lower fine mode resolution to 1
On Data page -> Volume, add isosurface and then change its value to 11 or similar
and change the color to use NagsHead_years_vol. Set the isosurface resolution to 1.
</code>
</pre>

<p>
<img src="./pictures/nags_head_nviz.png" alt="NagsHead space-time cube in wxNviz" style="width: 700px;"/>

<h2 id="visualization-of-solar-radiation">Visualization of solar radiation</h2>

<!-- TODO: here we have addons but they are linked,
moreover we have no way to say don't link -->
<p>
Start GRASS with location NC_spm_temporal_workshop and mapset centennial.

<p>
We will compute solar radiation during a day for a part of North Carolina State University Centennial Campus.
Then we will visualize the change of solar radiation as a 3D animation.
If you don't have r.sun.hourly, download it:

<pre><code class="neutral">
g.extension extension=r.sun.hourly
</code></pre>

<p>
Convert the today's date (or any other date) to day of year by running this command in Python shell tab in GUI.

<pre>
<code class="python">
from datetime import datetime
datetime.now().timetuple().tm_yday
# or for an arbitrary day:
datetime.datetime(2014, 6, 21).timetuple().tm_yday
</code>
</pre>

<p>
Use this number for option <code>day</code>.
Compute beam irradiance raster series (be patient) with the following command.
The time series is automatically registered into a space-time raster dataset.

<pre>
<code>
r.sun.hourly -t elev_in=elev_lid_small start_time=6 end_time=20 day=200 year=2014 beam_rad_basename=beam nprocs=4
</code>
</pre>
Set custom color table for just created dataset <code>beam</code>:
<pre>
<code class="gui">
Use interactive input box in t.rast.colors dialog
or add the following line with coordinates to a newly created rules.txt file:
0% 60:60:60
70% yellow
100% 255:70:0

t.rast.colors input=beam rules=rules.txt
</code>
<code class="bash">
echo "0% 60:60:60
      70% yellow
      100% 255:70:0" > rules.txt
t.rast.colors input=beam rules=rules.txt
</code>
</pre>

<p>
Finally, we animate the series in 3D. To do that, we first add <code>elev_lid_small</code> map in GUI,
zoom to it, and swith to 3D view.
We set desired view and resolution and then change the color by draping
over one of the solar radiation maps (see <a href="http://grass.osgeo.org/grass70/manuals/wxGUI.nviz.html#3d-view-layer-manager-toolbox">GUI manual</a>).
We save workspace to a file.
Then we launch animation tool and add new animation. Choose 3D, add the computed space-time raster dataset,
set saved workspace file and choose color_map option to animate.
Note that 3D animation are not supported on MS Windows.
<p>
<img src="./pictures/anim3_result.png" alt="solar radiation animation in 3D"/>

<hr>

<p><i>Last changed: 2014-08-13 22:00</i>
<p>
  <a href="http://grass.osgeo.org/grass71/manuals/">GRASS GIS manual main index</a> |
  <a href="http://grass.osgeo.org/grass71/manuals/temporal.html">Temporal modules index</a> |
  <a href="http://grass.osgeo.org/grass71/manuals/topics.html">Topics index</a> |
  <a href="http://grass.osgeo.org/grass71/manuals/keywords.html">Keywords Index</a> |
  <a href="http://grass.osgeo.org/grass71/manuals/full_index.html">Full index</a>
</p>
<p>
  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
    <img alt="Creative Commons License" src="ccbysa.png"></a>
  <br>
  Spatio-temporal data handling and visualization in GRASS GIS workshop for FOSS4G 2014
  by Vaclav Petras, Anna Petrasova, Helena Mitasova and Markus Neteler
  is licensed under&nbsp;a&nbsp;<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
</p>
  <script src="codetabs.js"></script>
</body>
</html>
