<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Spatio-temporal data handling and visualization in GRASS GIS</title>
  <meta name="description" content="">
  <meta name="author" content="">
  <link rel="shortcut icon" href="grass.png">

  <script src="jquery.js"></script>

<!--
<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/default.min.css">
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
-->

<link rel="stylesheet" href="highlightjs/styles/default.css">
<script src="highlightjs/highlight.pack.js"></script>


<style>
.hljs{
    display: none;
    /*padding: 0em;*/
}

</style>


  <link rel="stylesheet" href="grassdocs.css">
  <link rel="stylesheet" href="codetabs.css">

</head>

<body>


<h1>Spatio-temporal data handling and visualization in GRASS GIS</h1>
<p>
Vaclav Petras,
Anna Petrasova,
Helena Mitasova,
Markus Neteler
</p>

<p>FOSS4G 2014 workshop</p>

<p>
Outline:
<ul>
<li> analyze coastal terrain time series
<li> analyze climate data
<li> compute and visualize solar radiation dynamics
</ul>

<p>
Software:
<ul>
<li>GRASS GIS 7</li>
<li>matplotlib with pyplot
(included in GRASS installation for MS Windows; package python-matplotlib for Ubuntu)</li>
</ul>

<p>
Data:
<ul>
<li>location <a href="http://courses.ncsu.edu/mea592/common/media/02/nc_climate_spm_2000_2012.zip">NC climate</a>
<li>alternative color tables:
    <a href="http://courses.ncsu.edu/mea592/common/Assign_GISmdmodel/temperature_color.txt">temperature</a>,
    <a href="http://courses.ncsu.edu/mea592/common/Assign_GISmdmodel/precip_color.txt">precipitation</a>
<li>
location <a href="http://courses.ncsu.edu/mea592/common/gisdata/JockeysRidge.zip">NC spm</a> with JR mapset,
mapset <a href="http://courses.ncsu.edu/mea582/common/media/01/NagsHead_series.zip">NagsHead</a> to be copied to NC smp location,
</ul>

<p>
Terminology:
<ul>
<li>map in GRASS describes a spatial phenomena, map is stored in GRASS database,
  it can be raster, vector, or 3D raster (other GIS systems often call this a layer)</li>
<li>raster map usually describes a continuous spatial phenomena, examples include precipitation and aerial image</li>
<li>vector map usually describes a discrete spatial phenomena, for example meteorological stations</li>
<li>3D raster is a three dimensional raster, alternative names include voxel, voxel model and volume</li>
<li>spatio-temporal dataset in GRASS is a set of GRASS maps registered in GRASS temporal database</li>
<li>
  GRASS module is one function, procedure or algorithm,
  it can be also referred as command especially when also all parameters are given
  (other systems use also terms tool and program),
  module can be invoked from GUI, Python or system command line
</li>
<li>GUI is a graphical user interface, i.e. the windows which user usually sees after starting GRASS GIS
  (GUI in GRASS GIS is often referred as wxGUI because of the underlying technology)</li>
</ul>

<p>
Notes:
<ul>
<li>To run commands in GUI, fill the module
  parameters into a proper form or just type the type the relevant command
  into the command console in GUI and press enter.</li>
</ul>


<h2>Climate data analysis</h2>

<h3>Basic commands and visualizations</h3>
<p>
Start grass7 with location nc_climate_spm and mapset climate_2000_2012.
First we list available raster maps and display the first temperature
and precipitation maps from the series to make ourselves familiar with the data.

<pre>
<code>
g.mlist type=rast pattern="*tempmean"
g.mlist type=rast pattern="*precip"
</code>
</pre>

<pre>
<code class="gui">
Add raster map layer -> select 2000_01_tempmean
Add raster map layer -> select 2000_01_precip
</code>
<code class="bash">
# start monitor
d.mon wx0
# display raster maps
d.rast 2000_01_tempmean
d.rast 2000_01_precip
</code>
</pre>

To better handle the long time series of maps, we create temporal datasets
which serve as containers for the time series and we will further manipulate
them instead of the individual maps. First, we create empty datasets of type
strds (space-time raster dataset). Note, that we use absolute time.
<!-- TODO: explain what is temporal dataset "think about container", the type is strds STRDS-->

<pre>
<code>
t.create output=tempmean type=strds temporaltype=absolute title="Average temperature" description="Monthly temperature average in NC [deg C]"
t.create output=precip_sum type=strds temporaltype=absolute title="Preciptation" description="Monthly precipitation sums in NC [mm]"
</code>
</pre>

<p>
Now we register raster maps into yet empty space-time raster datasets
with start date 2000-01-01 and interval time with increment 1 month. 
We use g.mlist again (or g.list in future GRASS versions) to list them:

<pre>
<code class="gui">
List raster maps with g.mlist:
    g.mlist type=rast pattern="*tempmean" separator=comma --quiet
    g.mlist type=rast pattern="*precip" separator=comma --quiet
And than copy and paste output to maps parameter of t.register:
    t.register -i input=tempmean type=rast start=2000-01-01 increment="1 months" maps=...
    t.register -i input=precip_sum type=rast start=2000-01-01 increment="1 months" maps=...
</code>
<code class="bash">
# first list maps to check the pattern and output
g.mlist type=rast pattern="*tempmean" separator=comma --quiet
g.mlist type=rast pattern="*precip" separator=comma --quiet

# then use backticks to pass the maps directly to t.register
t.register -i input=tempmean type=rast start=2000-01-01 increment="1 months" \
    maps=`g.mlist type=rast pattern="*tempmean" separator=comma --quiet`
t.register -i input=precip_sum type=rast start=2000-01-01 increment="1 months" \
    maps=`g.mlist type=rast pattern="*precip" separator=comma --quiet`
</code>
</pre>

<p>
Make sure the datasets are created and populated correctly:
<pre>
<code>
t.list type=strds
t.rast.list input=tempmean sep=tab
</code>
</pre>

<p>
Another example of listing maps, this time we aggregate the output with temporal granularity 2 years:

<pre>
<code>
t.rast.list input=tempmean method=gran granule="2 years" sep=tab
</code>
</pre>
<pre>
<samp>
id	name	mapset	start_time	end_time	interval_length	distance_from_begin
2000_01_tempmean@climate_2000_2012	2000_01_tempmean	climate_2000_2012	2000-01-01 00:00:00	2002-01-01 00:00:00	731.0	0.0
2002_01_tempmean@climate_2000_2012	2002_01_tempmean	climate_2000_2012	2002-01-01 00:00:00	2004-01-01 00:00:00	730.0	731.0
2004_01_tempmean@climate_2000_2012	2004_01_tempmean	climate_2000_2012	2004-01-01 00:00:00	2006-01-01 00:00:00	731.0	1461.0
2006_01_tempmean@climate_2000_2012	2006_01_tempmean	climate_2000_2012	2006-01-01 00:00:00	2008-01-01 00:00:00	730.0	2192.0
2008_01_tempmean@climate_2000_2012	2008_01_tempmean	climate_2000_2012	2008-01-01 00:00:00	2010-01-01 00:00:00	731.0	2922.0
2010_01_tempmean@climate_2000_2012	2010_01_tempmean	climate_2000_2012	2010-01-01 00:00:00	2012-01-01 00:00:00	730.0	3653.0
2012_01_tempmean@climate_2000_2012	2012_01_tempmean	climate_2000_2012	2012-01-01 00:00:00	2014-01-01 00:00:00	731.0	4383.0
</samp>
</pre>

<p>
Get some info about the newly created dataset:
<pre>
<code>
t.info tempmean
</code>
</pre>

<p>
<pre>
<samp>
+-------------------- Space Time Raster Dataset -----------------------------+
|                                                                            |
+-------------------- Basic information -------------------------------------+
| Id: ........................ tempmean@climate_2000_2012
| Name: ...................... tempmean
| Mapset: .................... climate_2000_2012
| Creator: ................... anna
| Temporal type: ............. absolute
| Creation time: ............. 2014-07-11 12:40:57.473036
| Modification time:.......... 2014-07-11 12:41:06.799619
| Semantic type:.............. mean
+-------------------- Absolute time -----------------------------------------+
| Start time:................. 2000-01-01 00:00:00
| End time:................... 2013-01-01 00:00:00
| Granularity:................ 1 month
| Temporal type of maps:...... interval
+-------------------- Spatial extent ----------------------------------------+
| ...
</samp>
</pre>


<p>
Visualize spatio-temporal extents:

<pre>
<code class="neutral">
g.gui.timeline tempmean
</code>
</pre>
<img src="./pictures/timeline_tempmean.png" alt="plot of temporal extents of tempmean strds",
title="Plot of temporal extents of space-time raster dataset tempmean"></img>



<!--
comment this out if necessary
-->
<p>
Query space-time raster dataset in a point and display the values in a plot
(available only in the newest GRASS GIS 7 version).
<pre>
<code>
g.gui.tplot inputs=precip_sum coordinates=366165,218084
</code>
</pre>
<img src="./pictures/tplot_precip_sum.png" alt="plot of values from certain coordinate"></img>

<p>
Now we will extract one year from both space-time raster datasets.
In this case, no new maps are created, the newly created dataset just points to the old maps.
<pre>
<code>
t.rast.extract input=tempmean output=tempmean_2010 where="start_time &gt;= '2010-01-01' and start_time &lt; '2011-01-01'"
t.rast.extract input=precip_sum output=precip_sum_2010 where="start_time &gt;= '2010-01-01' and start_time &lt; '2011-01-01'"
</code>
</pre>
We list the maps in the newly created dataset.
<pre>
<code>
# simple listing
t.rast.list tempmean_2010
# we can choose different columns and order
t.rast.list input=tempmean_2010 columns=name,start_time,end_time,min,max sep="  "
t.rast.list input=precip_sum_2010 columns=start_time,min order=min sep="  "
# display temporal extents
g.gui.timeline inputs=tempmean,precip_sum,tempmean_2010,precip_sum_2010
</code>
</pre>
<img src="./pictures/timeline_extracted.png" alt="extracted datasets"></img>

<p>
Now let's look at univariate statistics using t.rast.univar with temporal where option to limit output.
The default separator (pipe) can be changed with separator option.
<pre>
<code>
t.rast.univar -h tempmean_2010 where="start_time &gt; '2010-10-01'"
</code>
</pre>
<pre>
<samp>
id|start|end|mean|min|max|mean_of_abs|stddev|variance|coeff_var|sum|null_cells|cells
2010_10_tempmean@climate_2000_2012|2010-10-01 00:00:00|2010-11-01 00:00:00|16.2275459748922|9.80648888481988|19.2237726847331|16.2275459748922|1.83784116074554|3.37766013213051|11.3254410962021|8233321.31864314|503233|1010600
2010_11_tempmean@climate_2000_2012|2010-11-01 00:00:00|2010-12-01 00:00:00|10.0550104277932|3.83957968817817|13.2355732387967|10.0550104277932|1.49157983140112|2.2248103934426|14.8341947739629|5101580.47571814|503233|1010600
2010_12_tempmean@climate_2000_2012|2010-12-01 00:00:00|2011-01-01 00:00:00|0.929180131463252|-6.46433724297418|4.24769083658854|1.58153627012032|1.56125262006063|2.43750974364618|168.024752918684|471435.335760116|503233|1010600
</samp>
</pre>

<p>
Create a synchronized animation of two space-time datasets.
Run g.gui.animation and <a href="./pictures/anim1.png">add two animations</a>,
one for <code>tempmean_2010</code> and the other for <code>precip_sum_2010</code> dataset.
Display legend and set min and max values in legend using the information from t.info.
<p>
<img src="./pictures/anim1_result.png" style="width: 600px;" alt="Result from Animation Tool"></img>

<p>
Change color table if desired (to built-in color table precipitaton_monthly or create your own color table).
To see the change in the animation tool, click on Render map which reloads all maps.
<pre>
<code>
t.rast.colors input=precip_2012 rules=precipitation_monthly
</code>
</pre>

<p>
Now we remove these two extracted spatio-temporal datasets. Note: in this case we remove the just the "container",
not the actual maps.
<pre>
<code>
t.remove inputs=tempmean_2010,precip_sum_2010
t.list
</code>
</pre>
<pre>
<samp>
Space time raster datasets with absolute time available in mapset <climate_2000_2012>:
precip_sum@climate_2000_2012
tempmean@climate_2000_2012
</samp>
</pre>



<h3>Time series analysis</h3>

<p>
We will now aggregate time series by seasons using average aggregation method.
We use where option to start aggregating the first of March.

<pre>
<code>
t.rast.aggregate input=tempmean output=tempmean_seasonal base=tempmean_seasonal granularity="3 months" method=average where="start_time &gt;= '2000-03-01' and start_time &lt; '2012-11-01'"
</code>
</pre>

<p>
Extract summer periods and convert to degrees Fahrenheit.
SQLite function <tt>strftime('%m', start_time)</tt> returns the month of
the map start timestamp.
Note that <tt>strftime</tt> function is not a GRASS function.
It is specific to SQLite (temporal database) backend,
you need to use something different if you are using PostgreSQL backend.
Using nprocs=4 we are telling t.rast.extract to use 4 processes which will be
distributed to 4 processor cores if available.

<pre>
<code>
t.rast.extract input=tempmean_seasonal where="strftime('%m', start_time)='06'" expression="(tempmean_seasonal  * 9.0/5.0) + 32" output=tempmean_F_summer base=tempmean_F_summer nprocs=4
</code>
</pre>
<img src="./pictures/timeline_tempmean_seasonal.png" alt="temporal extents of tempmean_seasonal"></img>
<p>
Show plot of min and max values of summer periods.
We will first create a file with those values.
If you want, set working directory from menu in GUI or by <tt>cd</tt> command,
otherwise you will have to use full path instead of just a file name.

<pre>
<code class="bash">
# you must be in the same directory as you switched GUI to
# or you must use full path
t.rast.list -h input=tempmean_F_summer columns=start_time,min,max separator=comma > temperatures.txt
</code>
<code class="gui">
Run t.rast.list and copy output to a file named temperatures.txt
t.rast.list -h input=tempmean_F_summer columns=start_time,min,max separator=comma
</code>
</pre>

<p>
Now go to Python shell tab in the wxGUI and copy and paste:

<pre>
<code class="python">
import matplotlib.pyplot as plt
plt.plotfile("temperatures.txt", cols=(0,1,2), delimiter=',', subplots=False)
plt.show()
</code>
</pre>
<img src="./pictures/plot_summer_minmax.png" alt="minimum and maximum temperatures in summer"></img>


<p>
Let's do the same with precipitation dataset in a different way.
Aggregate data using time intervals of tempmean_F_summer.
Convert millimeters to inches.

<pre>
<code>
t.rast.aggregate.ds input=precip_sum sample=tempmean_F_summer output=precip_summer base=precip_summer method=average
t.rast.mapcalc inputs=precip_summer expression="precip_summer / 25.4" output=precip_inch_summer base=precip_inch_summer nprocs=4
</code>
</pre>

<p>
Is precipitation and temperature correlated?
We will use r.regression.series, which is a GRASS addon. If you don't have it installed,
download it from GRASS Addons:

<pre>
<code>
g.extension extension=r.regression.series
</code>
</pre>

<p>
Now we determine the correlation. Note that r.regression.series does not accept 
spatio-temporal datasets yet, just individual maps:

<pre>
<code class="gui">
Run g.mlist two times and then use the outputs as inputs to xseries and yseries parameters of
the r.regression.series module:
    g.mlist type=rast pattern="tempmean_F_summer*" separator=comma --q
    g.mlist type=rast pattern="precip_inch_summer*" separator=comma --q

    r.regression.series xseries=... yseries=... output=corr method=corcoef
</code>
<code class="bash">
# using backticks syntax for two g.mlist runs
r.regression.series \
    xseries=`g.mlist type=rast pattern="tempmean_F_summer*" separator=comma --q` \
    yseries=`g.mlist type=rast pattern="precip_inch_summer*" separator=comma --q` \
    output=corr method=corcoef
</code>
</pre>

<p>
Set color table of <code>corr</code> raster map to differences color table.
<pre>
<code>
r.colors map=corr color=differences
</code>
</pre>

<p>
Now we can explore the map <code>corr</code> showing mostly negative
spatial correlation between temperature and precipitation.
<pre>
<code class="gui">
Add raster map layer -> select corr
Add map elements -> Show/hide legend
</code>
<code class="bash">
# display raster maps
d.rast corr
d.legend corr
</code>
</pre>
<img src="./pictures/corr.png" alt="temperature and precipitation spatially correlated"></img>


<p>
Now we will plot temperatures in Raleigh and Ashville. First we create vector maps
with sampling locations.

<pre>
<code class="bash">
echo "638863,225446
      287621,210637" | v.in.ascii -t input=- output=towns separator=comma
</code>
<code class="gui">
Use interactive input box in v.in.ascii dialog
or add the following line with coordinates to a newly created point.txt file:
638863,225446
287621,210637
and use the following parameters:
v.in.ascii -t input=point.txt output=raleigh separator=comma
</code>
</pre>


<p>
Then, using t.vect.observe.strds, we create a space-time vector dataset
with values of summer temperature in those two locations stored in the attribute tables:

<pre>
<code>
t.vect.observe.strds input=towns strds=tempmean_F_summer output=towns_tempmean_summer vector_output=towns_summer column=tempmean
</code>
</pre>

<p>
Now we list temperature values:

<pre>
<code>
t.vect.db.select input=towns_tempmean_summer columns=tempmean separator=comma where="cat = 1" > raleigh.txt
t.vect.db.select input=towns_tempmean_summer columns=tempmean separator=comma where="cat = 2" > asheville.txt
</code>
</pre>

<p>
Plot the values using matplotlib (in GUI in Python console):
<pre>
<code class="python">
plt.plotfile("raleigh.txt", cols=(0,2), delimiter=',', subplots=False)
plt.plotfile("asheville.txt", cols=(0,2), delimiter=',', subplots=False, newfig=False)
plt.show()
</code>
</pre>
<img src="./pictures/plot_summer_towns.png" alt="plot of summer temperatures in two towns"></img>

<p>
Now we will display an animation of summer temperature in North Carolina
and we will overlay the vector points representing the two towns.
Before we display the maps, we set color table of the entire time series.

<pre><code class="neutral">
t.rast.colors input=tempmean_F_summer color=byr
g.gui.animation tempmean_F_summer
</code></pre>
<img src="./pictures/anim2_result.png" alt="animation of summer temperature in North Carolina"></img>

<h2>NagsHead series</h2>

<p>
Start grass7 with location north_carolina_spm and mapset NaghHead_series. TODO revise names of location

<p>
First, we create an empty space-time raster dataset. We will use relative time with years as units.

<pre>
<code>
t.create output=NagsHead_99_08 type=strds temporaltype=relative title="Nags Head elevation series" description="from 1999 to 2008 with gaps"
</code>
</pre>

<p>
Check whether it was successfull:
<pre>
<code>
t.list type=strds
</code>
</pre>

<p>
Register maps in the dataset using the list of maps bellow.
Each map has an associated year. The default separator is a pipe.

<pre>
<code class="gui">
In t.register dialog, use an interactive input box for the file option and
copy and paste the list of the maps:
NH_1999_1m|1999
NH_2001_1m|2001
NH_2004_1m|2004
NH_2005_1m|2005
NH_2007_1m|2007
NH_2008_1m|2008

Also, use the other options bellow:
t.register input=NagsHead_99_08 type=rast unit=years
</code>
<code class="bash">
echo "NH_1999_1m|1999
      NH_2001_1m|2001
      NH_2004_1m|2004
      NH_2005_1m|2005
      NH_2007_1m|2007
      NH_2008_1m|2008" > NH.txt
t.register input=NagsHead_99_08 type=rast file=NH.txt unit=years
</code>
</pre>

<p>
Check dataset again, pay special attention to 'Relative time' section
and a number of registered maps under 'Metadata information'.

<pre>
<code>
t.info -h input=NagsHead_99_08
t.rast.list NagsHead_99_08
g.gui.timeline NagsHead_99_08
</code>
</pre>
<img src="./pictures/timeline_nagshead_gaps.png" alt="temporal extents of NagsHead dataset"></img>


<p>
Since there are gaps in the dataset, we need to interpolate missing data.
The interpolated maps are already in the mapset so you can skip this step.
The maps were linearly interpolated with r.series.interp. For interval data,
you could use t.rast.gapfill.

<pre>
<code>
g.region rast=NH_1999_1m -p
r.series.interp input=NH_1999_1m,NH_2001_1m,NH_2004_1m,NH_2005_1m,NH_2007_1m,NH_2008_1m datapos=1999,2001,2004,2005,2007,2008 output=NH_2000_1m_interp,NH_2002_1m_interp,NH_2003_1m_interp,NH_2006_1m_interp sampl=2000,2002,2003,2006
</code>
</pre>

<p>
Now we register interpolated maps to the existing dataset.

<pre>
<code class="gui">
Use interactive input for the file option in the dialog of t.register
module. Use parameters input=NagsHead_99_08 and unit=years.
Here is the list of maps to be registered including the time stamps:

NH_2000_1m_interp|2000
NH_2002_1m_interp|2002
NH_2003_1m_interp|2003
NH_2006_1m_interp|2006
</code>
<code class="bash">
echo "NH_2000_1m_interp|2000
      NH_2002_1m_interp|2002
      NH_2003_1m_interp|2003
      NH_2006_1m_interp|2006" > interp.txt

t.register input=NagsHead_99_08 file=interp.txt unit=years
</code>
</pre>

<p>
Check what you have now in the temporal database.
Set the same color table for all maps.

<pre>
<code>
t.rast.list -h NagsHead_99_08
t.rast.colors input=NagsHead_99_08 raster=NH_1999_1m
g.gui.timeline NagsHead_99_08
</code>
</pre>

<p>
Display animation of space-time raster data set, first just in 2D.

<pre>
<code class="neutral">
g.gui.animation strds=NagsHead_99_08
</code>
<code class="gui">
In main menu use File > Animation tool.
</code>
</pre>


<p>
We can also display 2D and 3D animation side by side. To display animation in 3D,
we first have to prepare and store 3D view parameters. To do that, launch GUI if not already launched,
add e.g. NH_1999_1m, go to 3D view, set view and resolution as desired 
(see <a href="http://grass.osgeo.org/grass70/manuals/wxGUI.nviz.html#3d-view-layer-manager-toolbox">GUI manual</a>),
 and save workspace file.
In Animation tool, add animation, choose 3D mode, set workspace file,
and leave there <tt>elevation_map</tt>.
Note that 3D in Animation tool (as well as m.nviz.image command bellow)
is not supported on MS Windows.
<p>
<!-- got black box for 3D animation on 10.6, try it on Mac 10.8. -->
<img src="./pictures/anim4_result.png" alt="NagsHead series 2D and 3D animation" style="width: 600px;"></img>

<p>
Sidenote: for scripting or working in command line, you can save your 3D settings
as m.nviz.image command using the button on GIS Layer manager (second row) called 'Generate command for m.nviz.image'.
Here is an example of a saved command:

<!-- TODO: implement saving as python -->
<pre>
<code>
m.nviz.image elevation_map=NH_1999_1m -a mode=fine resolution_fine=1 color_map=NH_1999_1m position=0.94,0.87 height=789 perspective=15 twist=0 zexag=2.000000 focus=487,469,8 light_position=0.68,-0.68,0.80 light_brightness=80 light_ambient=20 light_color=255:255:255 output=nviz_output format=ppm size=718,699
</code>
</pre>

<h3>Space-time cube representation</h3>
<p>
Space-time cube is 3-dimensional representation where z-coordinate is time.
We use 3D raster to represent space-time cube with z-coordinates as values of the 3D raster.
<p>
To create space-time cube we vertically stack the series of digital elevation models:

<pre>
<code>
t.rast.to.rast3 input=NagsHead_99_08 output=NagsHead_99_08_vol
r3.info -g map=NagsHead_99_08_vol
g.region rast3d=NagsHead_99_08_vol -p3
</code>
</pre>

<!-- TODO: see how this is in 70 branch, display legend -->
<p>
Now, create a new 3D raster which will be used for coloring isosurfaces by years.

<pre>
<code>
t.rast.mapcalc inputs=NagsHead_99_08 expression="start_time() + 1999" output=NagsHead_years basename=NagsHead_years nprocs=4
t.rast.to.rast3 input=NagsHead_years output=NagsHead_years_vol

# set color table of the space-time cube 3D raster
r3.colors map=NagsHead_99_08_vol color=elevation
</code>
</pre>

<p>
Now we will display the space-time cube in 3D. Follow the instructions below:
<pre>
<code class="gui">
# set lower resolution to speed up 3D rendering
g.region -p3 res3=3 tbres=1

# first we add DEM from 2008 which was divided by 20 for visualization purpose in 3D view
# because we have to use big exaggeration for the 3D raster
Add raster map layer -> select NH_2008_1m_0.05
Add various raster map layers -> Add 3D raster map layer -> select NagsHead_99_08_vol
Right click on 3D raster -> Zoom to selected map
Paste d.legend command into GUI Command console:
d.legend -f rast3d=NagsHead_years_vol at=5,50,7,10 use=1999,2000,2001,2002,2003,2004,2005,2006,2007,2008
Switch to 3D view (be patient)
On View page, set z-exaggeration to 20 and view height to 100.
On Data page -> Surface, lower fine mode resolution to 1 or 2
On Data page -> Volume, add isosurface and then change its value to 11 or similar
and change the color to use NagsHead_years_vol. Set the isosurface resolution to 1.
</code>
</pre>

<p>
<img src="./pictures/nags_head_nviz.png" alt="NagsHead space-time cube in wxNviz" style="width: 700px;"></img>

<h2>Visualization of solar radiation</h2>

<!-- TODO: here we have addons but they are linked,
moreover we have no way to say don't link -->
<p>
We will compute solar radiation during a day for a part of North Carolina State University Centennial Campus.
Then we will visualize the change of solar radiation as a 3D animation.
If you don't have r.sun.hourly, download it:

<pre><code>
g.extension extension=r.sun.hourly
</code></pre>

<p>
Convert the today's date (or any other date) to day of year by running this command in Python shell tab in GUI.

<pre>
<code class="python">
from datetime import datetime
datetime.now().timetuple().tm_yday
# or for an arbitrary day:
datetime.datetime(2014, 6, 21).timetuple().tm_yday
</code>
</pre>

<p>
Use this number for option <code>day</code>.
Compute beam irradiance raster series (be patient) with the following command.
The time series is automatically registered into a space-time raster dataset.

<pre>
<code>
r.sun.hourly -t elev_in=elev_lid_small start_time=6 end_time=20 day=200 year=2014 beam_rad_basename=beam nprocs=4
</code>
</pre>
Set custom color table for just created dataset <code>beam</code>:
<pre>
<code class="bash">
echo "0% 60:60:60
      70% yellow
      100% 255:70:0" > rules.txt
t.rast.colors input=beam rules=rules.txt
</code>
<code class="gui">
Use interactive input box in t.rast.colors dialog
or add the following line with coordinates to a newly created rules.txt file:
0% 60:60:60
70% yellow
100% 255:70:0

t.rast.colors input=beam rules=rules.txt
</code>
</pre>

<p>
Finally, we animate the series in 3D. To do that, we first add <code>elev_lid_small</code> map in GUI,
zoom to it, and swith to 3D view.
We set desired view and resolution and then change the color by draping
over one of the solar radiation maps (see <a href="http://grass.osgeo.org/grass70/manuals/wxGUI.nviz.html#3d-view-layer-manager-toolbox">GUI manual</a>).
We save workspace to a file.
Then we launch animation tool and add new animation. Choose 3D, add the computed space-time raster dataset,
set saved workspace file and choose color_map option to animate.
Note that 3D animation are not supported on MS Windows.
<p>
<img src="./pictures/anim3_result.png" alt="solar radiation animation in 3D"></img>

</p>
<!-- the last tag must be closed -->

  <script src="codetabs.js"></script>
</body>
</html>
